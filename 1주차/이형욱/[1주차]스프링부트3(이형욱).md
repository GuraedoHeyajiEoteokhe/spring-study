
# 01. 자바 백엔드 개발자가 알아두면 좋은 지식

> pg 039 - 050
>

### 서버와 클라이언트

서버와 클라이언트는 서로 요청과 응답을 주고 받는 관계를 맺는다. 클라이언트가 서버에게 “해당 인터넷 주소의 정보를 달라”고 요청하고, 서버는 그 요청을 받아 클라이언트에게 정보를 보내준다.

### 데이터베이스

데이터를 모아두고 사용하는 저장고이다. 이는 말 그대로 데이터를 모아두는 곳이고, Database(이하 DB)를 관리하는 것이 RDB이다.

MySql, DBeaver 등 데이터베이스를 행과 열로 이루어진 테이블로 관리하는 것들을 관계형 데이터베이스(Relational Database) 라고 한다. RDB에서 DB를 컨트롤하는 언어를 Structured Query Language(이하 SQL)라고 한다.

반면 Not Only SQL(NoSQL)이라는 것도 있는데, 이는 스케일 아웃될 때 성능이 떨어지는 SQL의 문제를 해결하기 위해 등장했다.

NoSQL에는 모델링에 따라 다이나모디비, 카우치베이스, 몽고디비 등이 있다.

### 아이피와 포트

Internet Protocol(IP)이란 인터넷에서 기기들이 서로를 알아보기 위한 주소이다. 호텔의 주소가 IP라면 호텔 방 번호가 Port다. IP를 가지고 있으면 서버를 찾을 수 있지만 사용하지 못한다. Port가 있어야 서버에 접속가능하다.

### 라이브러리&프레임워크

아무런 정보와 도움 없이 혼자서 개발을 하려면 많은 시간과 노력이 필요할 것이다. 라이브러리와 프레임워크는 이미 다른 단체(혹은 사람이) 만들어서 정리해 놓은 것이다. 라이브러리를 사용하면, 이미 만들어진 코드들을 의존성으로 나의 프로그램에 붙여서 끌어다 사용할 수 있다. 프레임워크는 개발자가 개발을 수월하게 할 수 있도록 도움을 주는 틀을 제공한다.


- 프레임워크는 개발할 때 구조적인 도움을 받기 위해 사용하는 것이고 라이브러리는 개발할 때 필요한 기능을 구현하는데 도움을 받기 위해 사용하는 것이다.

### 백엔드 개발자의 업무

백엔드 개발자는 서버 측 어플리케이션을 개발하는 일을 하는 직무로, 개발하며 서버에 대한 지식과 프로그래밍 지식, 만든 프로그램을 배포하고 안전하게 서비스를 제공하는 지식을 활용한다.

백엔드 개발자의 업무를 7단계로 나누어보자.

> 1. 과제 할당
>2. 과제 분석
>3. 개발
>4. 테스트
>5. QA
>6. 배포유지보수

1. 과제 할당

   타 부서에서 개발 과제를 할당한다.

2. 과제 분석

   주어진 과제가. “친구 초대 이벤트 제작” 이라면, 아래와 같이 분석할 수 있다.

    1. 친구는 누구인지
    2. 초대는 무엇을 의미하는지
    3. 이벤트는 어떤 조건이 필요한지
    4. 초대한 사용자와 초대된 친구에게 어떤 보상을 줄지
    5. 이벤트를 위해 어떤 데이터를 저장하는지

   이 뿐 아니라 서비스 성능과 사용할 기술 등을 면밀히 분석해야 한다.

3. 개발

   개발 단계에서는 기능 개발, 버그 수정 등을 진행하며 협업 도구를 통해 개발자 간 리뷰 및 리뷰 반영을 통해 코드의 완성도를 높인다.

4. 테스트

   개발을 마치면 로직상 문제 확인, 성능 한계 확인, 가독성 확인을 하며 테스트를 진행한다. 테스트를 먼저 작성하여 개발을 진행하는 것을 테스트 주도 개발 기법이라고 한다.

5. QA

   Quality Assurance(QA) 단계를 통해 애플리케이션 품질을 높인다.

6. 배포와 유지보수

### 자바 Annotation

자바의 어노테이션은 메타 데이터로 주로 사용된다. 어떤 기능을 의미하는지 명시적으로 나타낸다.

# 02장 스프링 부트3 시작하기

## 2.1 스프링과 스프링 부트

스프링은 개발자들이 복잡하고 어려운 개발에 집중할 수 있도록 서버 성능, 안정성, 보안을 높은 수준으로 제공하는 프레임워크이다.

스프링 부트는 스프링의 복잡한 설정을 보완하고 비지니스 로직에 더욱 집중할 수 있도록 출시된 도구이다.

<aside>

- 스프링부트에는 톰켓, 제티, 언더토우 같은 웹 어플리케이션이 내장되어 있어서 이를 설치하지 않고 독립적으로 사용할 수 있다.
- 빌드 구성을 단순화하는 스프링 부트 스타터를 제공한다.
- XML  설정을 하지 않고 JAVA로만 개발이 가능하다.
- JAR를 이용해서 자바 옵션만으로 배포가 가능하다.
- 스프링 액츄에이터(spring actuator)를 제공한다.
</aside>

|  | 스프링 | 스프링 부트 |
| --- | --- | --- |
| 목적 | 엔터프라이즈 애플리케이션 개발을 더 쉽게 | 스프링을 더 쉽게 |
| 설정 파일 | 개발자가 구성 | 자동 |
| 개발 환경 구축 | 일부는 직접 생성 및 관리 | 사용 ❌ |
| 인메모리 DB 지원 | 지원 ❌ | 지원 ⭕ |
| 서버 | 별도로 수정 설정 | 내장형 서버 제공 |

## 2.2 스프링 콘셉트

### **제어의 역전과 의존성 주입**

`IoC`

기존에는 개발자가 클래스를 사용 하기 위해 직접 객체를 생성했었다면, Inversion of Control(제어 역전) 는 스프링 컨테이너가 객체를 관리하고 제공하는 것이다.

`DI`

Dependencyt Injection이란 IoC를 구현하기 위해 사용하는 방법 즉, 의존성 주입이다. DI는 IoC 컨테이너를 통해 Bean 객체를 건네받아 개발자가 직접 필요한 객체를 생성하지 않고도 Bean 객체를 통해 이용할 수 있다.


### **빈과 스프링 컨텐이너**

`스프링 컨테이너`

빈이 생성되고 소멸되는 시점인 생명주기를 관리하는 역할을 하며, 애너테이션을 통해 빈을 주입받을 수 있도록 DI를 지원한다.

`빈`

빈은 스프링 컨테이너에서 제공하는 객체이다.

### **관점 지향 프로그래밍**

Aspect Oriented Programming, AOP는 프로그램에 대한 접근법을 핵심관점, 부가관점의 시점으로 분리하여 모아두는 것을 의미한다.

예를 들어서 조금 더 설명을 해보자면, 계좌 이체, 고객 관리하는 프로그램이 있다고 해보자. 각 프로그램에는 기록을 관리하는 로깅과 데이터베이스 연결 기능이 있을 것이다. 이때 계좌 이체와 고객 관리는 핵심 관점으로 분류할 수 있을 것이고, 로깅과 데이터베이스 연결은 부가 관점으로 분류 할 수 있을 것이다. 이렇게 하여 핵심 관점과 부가 관점을 분리할 수 있게 한다.

이로써 핵심 관점 코드에만 집중 + 프로그램 변경&확장에도 유연하게 대응 가능하다.

### 이식 가능한 서비스 추상화

Portable Service Abstraction(PSA) 는 스프링에서 제공하는 다양한 기술들을 추상화해 개발자가 쉽게 사용하는 **인터페이스**를 뜻한다.

예를 들어 일괄된 방식으로 데이터 베이스에 접근하는 인터페이스를 지원하는 기술에 JPA, MyBatis, JDBC 같은 것들이 존재한다. 톰캣, 언더토우, 네티도 서로 다른 인터페이스 이지만 동일한 코드를 그대로 사용하는 WAS 이다.

59페이지(pdf61)

## 2.3 스프링 부트 3 둘러보기

### 첫 번째 스프링 부트3 예제 만들기

```
http://localhost:8080/test
```

- `localhost` : 현재 사용 중인 컴퓨터
- `8080` : 포트번호
- `/test` : 경로

```java
@RestController
public class TestController {
		@GetMapping("/test")
		public String test() {
				return "Hello, world!";
		}
}
```

- `@RestController` : Spring MVC에서 REST API를 만들 때 사용하는 컨트롤러 전용 어노테이션이다. 이는 `@Controller` + `@ResponseBody` 를 합쳐놓은 어노테이션이다.

  즉, 메서드의 반환값을 View(HTML)로 해석하지 않고, HTTP 응답 Body에 그대로 담아 JSON 또는 문자열 형태로 반환한다. (수업시간에 배운 Body: 문자열 혹은 JSON 형태 반환)

- `@RestController`= HTTP 요청 → Java 객체 처리 → JSON 응답

  `@Controller`= HTTP 요청 → Java → HTML View 렌더링


### 스프링 부트 스타터 살펴보기

| 스타터 | 설명 |
| --- | --- |
| spring-boot-starter-web | Spring MVC를 사용해서 RESTful 웹 서비스를 개발할 때 필요한 의존성 모음 |
| spring-boot-starter-test | 스프링 애플리케이션을 테스트하기 위해 필요한 의존성 모음 |
| spring-boot-starter-validation | 유효성 검사를 위해 필요한 의존성 모음 |
| spring-boot-starter-actuator | 모니터링을 위해 애플리케이션에서 제공하는 다양한 정보를 제공하기 쉽게 하는 의존성 모음 |
| spring-boot-starter-data-jpa | ORM을 사용하기 위한 인터페이스의 모음인 JPA를 더 쉽게 사용하기 위한 의존성 모음 |

### 자동구성

스프링 부트는 서버를 시작할 때 구성 파일을 읽어와서 설정한다. 이를 자동 설정이라 한다. 자동 설정은 `META-INF` 에 있는 `spring.factories` 파일에 담겨있다. 이 안에 스프링 부트를 시작할 때 사용할 클래스들을 자동으로 등록해 주는 것이다.

## 2.4 스프링 부트 3 코드 이해하기

### `@SpringBootApplication 이해하기`

```java
@SpringBootApplication
public class SpringBootDeveloperApplication {
		public static void main(String[] args) {
				SpringApplication.run(SpringBootDeveloperApplication.class, args);
		}
}
```

- 자바의 main() 메서드와 같은 역할 수행 → 스프링부트 시작 지점

`@SpringBootApplication` : 기본 설정 시작

`args` :

1. 메인클래스로 사용할 클래스
2. 커맨드 라인의 인수들 전달

### 빈 등록

`@Component` 어노테이션은 `@Configuration`, `@Repository`, `@Service`, `@Controller` 에너테이션을 포함하고 있다.  @Component를 통해 빈을 등록하게 되는데, 위 에너테이션 모두 동일하게 Component를 가지고 있으므로 빈을 등록할 수 있다. 하지만 모두 각기 다른 역할을 수행하므로 역할에 맞게 어노테이션을 선택해야한다.

| 어노테이션 | 설명 |
| --- | --- |
| @Configuration | 설정 파일 등록 |
| @Repository | ORM 매핑 |
| @Controller, @RestController | 라우터 |
| @Service | 비지니스 로직 |

# 03장. 스프링 부트 3 구조 이해하기

> pg 077 - 095
>

## 3-1. 스프링 부트3 구조

### 계층 이해

**프레젠테이션 계층(Controller)**

HTTP 요청을 받고 이 요청을 Service 계층으로 전송하는 역할을 한다.

**비지니스 계층**

비지니스 로직을 처리한다. 서비스를 만들기 위한 로직, 즉 웹사이트에 벌어지는 모든 작업을 구현하기 위한 것들을 말한다.

**퍼시스턴트 계층**

DB관련 로직을 처리하는 곳으로, Data Access Object 객체를 사용할 수도 있다. DAO는 DB계층과 상호작용하기 위한 객체이며 Repository가 그 역할을 수행한다.

### 스프링 부트 프로젝트 디렉터리

추천 프로젝트의 디렉터리 구성을 알아보자

**main**

코드 저장 공간

**test**

테스트 소스 코드 혹은 리소스 파일 저장 공간

**build.gradle**

빌드를 설정하는 파일.

**settings.gradle**

빌드할 프로젝트의 정보를 설정하는 파일

## 3-2. 실습

## 3-3. 스프링 부트 요청-응답 과정 이해


1. 클라이언트의 HTTP 요청

   Dispatcher Servlet 이 URL 분석 후 이 요청을 처리할 수 있는 컨트롤러 서치. 찾았다면 해당 컨트롤러로 넘김.

2. 해당 요청을 처리할 수 있는 메소드와 매칭됐다면 해다 메소드에서 서비스계층과 레파지토리 계층과 연결되어 데이터를 가져옴
3. View Resolver에서는 템플릿을 통해 HTML 문서 혹은 JSON, XML 등의 스트링 데이터를 생성.
4. 결과가 나왔다면 return

### Spring MVC Request 처리과정 이해돕기


Spring의 request 처리과정을 “식당 주문 시스템”으로 비유해서 이해해보자

1. Client (손님)

   손님의 역할을 한다. 메뉴를 골라 요청하는 역할.

   → HTTP Request

2. DispatcherServlet (키오스크/주문접수)
    - 모든 요청이 가장 먼저 도착하는 곳
    - 직접 음식을 만들지는 않지만 주문을 주방으로 보내는 역할을 한다.

   → 어떤 Controller에 보낼지 판단되면 보내게 되고, view Resolver를 호출하여 어떤 view에 가야 하는지 템플릿을 받아온다.

3. Handler Mapping ( 어느 쉐프가 주문을 받아 요리해야 하는지 알아내는 역할)
    - 어떤 URL요청이 어떤 Controller 메소드로 가야하는지 알려줌
4. Handler Adapter (쉐프가 중국 사람이라 통역사가 필요함. handler Adapter는 통역사)
    - DispatchServlet에서 직접 요청을 Controller메소드로 보내지 못하기 때문에 Handler Adapter를 통해서 호출한다.
5. Handler (Controller) (쉐프)
    - 들어온 요청을 처리하는 곳.
    - 데이터(식자재)를 꺼내 요청사항에 따라 조리해서 Model + View로 반환한다.
6. ViewResolver (완성된 요리 플레이팅)
    - 요리를 손님에게 전달하기 전에 플레이팅을 하는 것
    - Controller가 결과를 “result”과 같은 논리 이름을 반환하면 이것을 물리 주소로 변환해준다.

      "result" → `/template/result.html`

    - prefix + viewName + suffic 로 실체 파일을 찾는다.
    - 최종 보여줄 view 객체 반환
7. View (손님에게 나가는 음식 = HTML 화면
    - 손님에게 요리 전달
    - ViewResolver가 결과를 템플릿파일에 담은 것
    - Model model 데이터를 담아 최종 HTML으로 렌더링한다.

정리

Client가 요청 → DispatcherServlet이 받고 → HandlerMapping에서 목적지 찾고 → HandlerAdapter로 방식 맞춰 → Controller가 처리 → ViewResolver가 템플릿 찾고 → View가 HTML 만들어서 답장.