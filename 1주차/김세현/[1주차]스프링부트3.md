# Chap01. 자바 백엔드 개발자가 알아두면 좋은 지식
## 1.1 서버 & 클라이언트

### 클라이언트
- 서버로 요청하는 프로그램을 모두 일컬어 말함
EX) 크롬, 엣지, 사파리 등
클라이언트의 주소창에 서버의 주소를 입력해 `enter`를 눌러 정보를 요청하는 행위 => '서버에 요청한다'
### 서버
- 클라이언트의 요청을 받아 처리하는 주체
EX) 웹 브라우저에 주소를 입력 => 새로운 화면을 그리기 위한 데이터를 달라는 데이터 요청에 해당



#### 브라우저의 동작: 
1. 주소창에 URL(서버의 주소) 입력
2. 브라우저가 그 URL의 서버로 HTTP 요청을 전송
3. 서버가 응답(Response)을 브라우저에게 돌려줌
4. 브라우저가 응답 내용을 화면에 렌더링함
>브라우저는 "요청을 대신 날리는 배달원" 같은 역할

### 💡 정리

클라이언트(브라우저): 요청을 보내는 프로그램
서버: 요청을 처리하고 응답을 보내주는 컴퓨터
URL은 항상 서버의 주소
브라우저끼리는 절대 통신하지 않음
브라우저는 단지 “사용자 → 서버” 요청을 대신 전달하는 도구

## 1.2 데이터베이스
- 여러 사람이 데이터를 한 곳에 모아두고 여러 사람이 사용할 목적으로 관리하는 데이터 저장소

DBMS(database management system): 데이터베이스를 관리하기 위한 시스템으로 MySQL, 오라클 등이 존재
#### 동작 원리:
1. 클라이언트 -> DBMS에 sql언어와 같은 데이터베이스 조작어를 이용해 데이터를 요청
2. DBMS -> 데이터 베이스에서 데이터를 꺼내 응답

### RDB (Relational Database)
- 데이터를 행과 열로 이루어진 테이블로 관리
- 기본키를 사용해 각 행 식별
- 테이블 간 관계 생성 가능
- ex) oracle, mysql

### SQL (Structured Query Language)
- 데이터를 검색하는 언어

### NoSQL
- Not Only SQL
- BASE(Basically Available, Soft state, Eventual consistency)
- 약한 일관성 대신 무한 확장성
- ex) 몽고디비, 다이나모디비 등
```
데이터 베이스의 성능을 높이려면 머신의 성능을 좋게 하는 스케일 업 또는 머신을 여러 대로 분리하는 스케일 아웃 필요
스케일 업 -> 장비 업그레이드
스케일 다운 -> 데이터베이스 분산
RDB는 강한 일관성을 가짐 즉, 모든 노드가 같은 데이터를 가져야 함
ACID 트랜잭션 : 원자성, 일관성, 독립성, 지속성
트랜잭션을 사용하면 성능이 떨어지게 됨 (트랜잭션을 강하게 유지하려고 하면 스케일 아웃이 어려워지기 때문)
따라서 과정이 복잡하기 때문에 스케일 아웃이 어려움
반면 NoSQL은 일관성을 약하게 설정할 수 있기때문에 분산이 쉽고 이 이유로 성능을 높일 수 있는 것
```

### RDB vs NoSQL
| 구분             | RDB (관계형 데이터베이스)                   | NoSQL (비관계형 데이터베이스)                 |
| -------------- | ---------------------------------- | ----------------------------------- |
| **데이터 모델**     | 테이블(행·열) 기반의 정형 데이터                | 키-값, 문서, 컬럼, 그래프 등 비정형·반정형 지원       |
| **스키마**        | 고정 스키마(변경 시 ALTER 필요)              | 스키마 유연함(필드 추가 자유로움)                 |
| **조인(Join)**   | 강력한 조인 지원                          | 조인 지양(중복 데이터 허용)                    |
| **트랜잭션(ACID)** | 강력함 — 일관성과 무결성 유지                  | 약함 또는 부분 지원 — BASE 모델 채택            |
| **확장성**        | Scale-Up 중심(서버 성능을 올림)             | Scale-Out 중심(노드를 여러 개 늘림)           |
| **성능**         | 복잡한 쿼리, 조인에서 강함                    | 대용량·고성능 분산 처리에 강함                   |
| **데이터 일관성**    | 강한 일관성(Strong Consistency)         | 최종적 일관성(Eventual Consistency)       |
| **사용 예시**      | 금융, ERP, 주문/결제, 회원관리 등             | 로그 저장, 캐시, 실시간 분석, SNS 피드 등         |
| **대표 제품**      | MySQL, PostgreSQL, MariaDB, Oracle | MongoDB, Redis, Cassandra, DynamoDB |

## 1.3 아이피와 포트
아이피: 서버를 찾기 위한 번호
포트: 서버에서 운용되고 있는 서비스를 구분하기 위한 번호
> 아이피 : 백화점
포트: 각자 다른 물건을 살 수 있는 매장
ex) `https://www.naver.com`
`www.naver.com` => 아이피를 쉽게 알아보기 위한 이름표
`https://` => 서버의 443번 포트를 사용하기 위한 입력
우리가 실행한 스프링 부트 서버 => 8080 포트

## 1.4 라이브러리와 프레임워크
### 라이브러리
- 애플리케이션 개발에 필요한 기능인 클래스, 함수 등을 모아놓은 코드의 모음
- 개발하는 과정에서 필요한 기능을 구현하기 위해 사용
### 프레임워크
- 소프트웨어 개발을 수월하게 하기 위한 소프트웨어 개발 환경
- 장점: 개발 효율 높음 단점: 정해진 틀에서 개발해야 함
- 애플리케이션을 개발할 때 전체적인 구조를 잡기 위해 사용

## 1.5 백엔드 개발자의 업무
(1) 과제 할당
- 주어진 과제 할당 ex) 사업부, 마케팅, 개발팀 등에서 개발 과제 할당

(2) 과제 분석💡: 
- 제공할 성능과 사용할 기술 검토, 문제 해결 방법 분석 & 정리

(3) 개발
- 기능 개발 & 버그 수정

(4) 테스트
- 테스트하며 1-2-3을 반복 => 완성도 ⬆️

(5) QA
- 애플리케이션의 품질을 높이기 위해 quality assurance 신청

(6)~(7) 배포와 유지보수
- 배포
	- 롤링 배포: 특정 개수의 서버 돌아가며 배포
    - 블루 그린 배포: 똑같은 서버 인스턴스를 띄우고 로드밸런서 설정을 바꿈
    - 카나리 배포: 전체 서버의 특정 비율만큼 배포해보고 문제없는 경우 배포 늘림
    >로드밸런서: 클라이언트의 요청을 여러 대의 서버에 분산시켜 부하를 줄이고 서버의 가용성 및 응답 시간을 최적화하는 기술 또는 장치

- CI(Continuous Integratrion): 새로운 코드 변경 사항이 정기적으로 빌드 및 테스트해 저장소에 통합
- CD(Continuous Delivery & Continuous Deployment): 실제 프로덕션 환경까지 변경된 코드가 반영되는 것

## 1.6 백엔드 프로그래밍 언어
- Phython: 데이터 분야, 서버 개발
	- 프레임워크: flask, django, FastAPI
- C++: 게임 서버 개발
- Java: 서버 개발
	- 프레임워크: spring, spring boot
- JavaScript
	- 프레임워크: Express, NestJS
- C#
	- 프레임워크: .NET
## 자바 애너테이션(Java annotation)
- 자바로 작성한 코드에 추가하는 표식으로 @기호 사용(JDK 1.5버전 이상)
- 메타 데이터로 사용 (메타데이터: 데이터에 관한 구조화된 데이터로, 다른 데이터를 설명해 주는 데이터)
ex) @Override, @Deprecated, @SuppressWarnings

# Chap02. 스프링부트 3 시작하기
### 스프링
배경: 대규모의 복잡한 데이터를 관리하는 엔터프라이즈 애플리케이션이 점점 복잡해지면서 서버 성능, 안정성, 보안을 신경쓰면서 비즈니스 로직까지 개발하기 매우 어려워짐
=> 엔터프라이즈 애플리케이션을 위한 개발 환경을 제공함으로써 기능 개발에만 집중할 수 있도록 도와줌. 
`스프링 프레임워크` => 서버 성능, 안정성, 보안을 매우 높은 수준으로 제공

### 스프링부트
- 스프링 프레임워크 더 쉽고 빠르게 이용할 수 있도록 만들어주는 도구
```
 웹 애플리케이션 서버 내장 
스프링 부트 스타터 제공 (빌드 구성 단순화)
XML 설정 X => 자바 코드로 모두 작성 O
JAR를 이용해 자바 옵션만으로 배포 O
spring actuator 제공 (애플리케이션 모니터링 및 관리 도구)
```
### 스프링 vs 스프링부트
|  | 스프링 | 스프링부트 |
| :- | - | :-: |
| 구성 | 환경 구성 수동| 자동 로드 |
| 내장 was | X | O |
|목적|엔터프라이즈 애플리케이션 개발 더 쉽게 |스프링 개발 더 쉽게|
|설정 파일|수동|자동|
|XML|일부파일 xml로 직접 생성&관리|사용X|
|인메모리 데이터베이스 지원|X|자동 설정 지원|
|서버|수동 설정|내장형 서버 제공|

### 제어의 역전과 의존성 주입
>스프링은 모든 기능의 기반을 제어의 역전(IoC)과 의존성 주입(DI)에 두고 있음

#### IoC (Inversion of Control)
다른 객체를 직접 생성하거나 제어하는 것이 아니라 외부에서 관리하는 객체를 가져와 사용하는 것
```java
public class A{
	private B b 
    /* b = new B();와 같이 B객체를 직접 생성하는 것이 아님 */
}
```
#### DI (Dependency Injection)
=> 제어의 역전을 구현하기 위해 사용하는 방법
어떤 클래스가 다른 클래스에 의존 
객체를 주입받음
```java
public class A {
	// A에서 B를 주입받음
    @Autowired
    B b;
}
```
이전 방법: 클래스 A에서 B객체를 쓰고 싶은 경우 직접 생성
스프링: 스프링 컨테이너가 객체 B를 생성해 클래스 A에 주입해줌

### 빈과 스프링 컨테이너
#### 스프링 컨테이너
빈의 생명주기를 스프링 컨테이너에서 관리
빈을 주입받을 수 있게 DI를 지원해줌

#### 빈
스프링 컨테이너가 생성하고 관리하는 객체
클래스를 빈으로 등록하는 방법
ex)
```java
@Component
public class MyBean{
}
```
@Component 애너테이션을 붙여 MyBean클래스를 빈으로 등록.
빈의 이름은 클래스 이름의 첫 글자를 소문자로 바꿔 관리 MyBean => myBean

### 관점 지향 프로그래밍 (AOP: Aspeect Oriented Programming)
프로그래밍에 대한 관심을 핵심 관점, 부가 관점으로 나누어서 관심 기준으로 모듈화
로깅, 보안, 트랜잭션과 같은 공통 기능을 분리하여 하나의 책임을 가지게 하는 프로그래밍 기법
=> 핵심 관점 코드에만 집중 가능, 코드의 재사용으로 생상선 높이고 유지보수 용이하게 만듦

### 이식 가능한 서비스 추상화 (PSA: Portable Service Abstraction)
스프링에서 제공하는 다양한 기술들을 추상화해 개발자가 쉽게 사용하는 인터페이스
ex)
>
데이터베이스에 접근하기 위한 기술로는 JPA, MyBatis, JDBC 등이 있는데 이 중 어떤 기술을 사용하든 일관된 방식으로 데이터베이스에 접근하도록 인터페이스 지원

**IoC/DI** => 객체 간 의존 관계 설정
**AOP** => 핵심 관점과 부가 로직 분리 개발
**PSA** => 추상화된 다양한 서비스들을 일관된 방식으로 사용

### 자동 구성
애플리케이션이 최소한의 설정만으로도 실행되게 여러 부분을 자동으로 구성
자동 설정 : META-INF > spring.factories 파일에 담겨 있음
![](https://velog.velcdn.com/images/sekong/post/c4631431-157d-492f-952e-73517f314ffa/image.png)
프로젝트에 쓰일 구성 후보들이고 이 중 프로젝트에서 사용할 것들만 자동으로 구성해 등록
스프링 부트에서는 빈이 자동으로 등록되고 구성됨

`@SpringBootApplication` : 스프링 부트 사용에 필요한 기본 설정해줌
`SpringApplication.run(메인클래스,args)` : 애플리케이션 실행
1. `@SpringBootConfiguration`
- 스프링 부트 관련 설정을 나타냄
- `@Configuration` 상속

2. `@ComponentScan`
- 사용자가 등록한 빈을 읽고 등록
- 이 패키지 아래에서 `@Component`, `@Service`, `@Repository`, `@Controller` 등을 찾아서 스프링 빈으로 등록
- `@Component` 애너테이션을 가진 클래스들을 찾아 빈으로 등록하는 역할
- 모든 빈에 `@Component`만 사용하는 것이 아닌 이를 감싸는 애너테이션이 존재, 용도에 따라 다른 애너테이션을 사용
`@Configuration` : 설정 파일 등록
`@Repository`: ORM 매핑
`@Service`: 비즈니스 로직
`@Controller`, `@RestController`: 라우터
> 라우터: HTTP 요청과 메소드 연결하는 장치
클라이언트의 요청에 맞는 메소드 실행할 수 있음

3. `@EnableAutoConfiguration`
- 자동 구성 활성화
- 톰캣, 스프링 MVC, 데이터소스 등등을 자동으로 준비
- spring.factories에 있는 클래스 자동 설정

`@RestController` > `@Controller`와 `@ResponseBody` 이 합쳐짐
`@Controller` > `@Component` 존재. `@ComponentScan`을 통해 빈으로 등록
`@Configuration`,`@Repository`, `@Service`  모두 `@Component` 애너테이션 포함하고 있음. 역할 구분을 위해 다른 이름으로 덮어둔 것  

# Chap03. 스프링 부트3 구조 이해하기

### 스프링 부트3 구조
스프링 부트 계층: 프레젠테이션, 비즈니스, 퍼시턴스 계층 
#### 프레젠테이션 계층
- HTTP 요청 받고 이 요청을 비즈니스 계층으로 전송하는 역할
- Controller
#### 비즈니스 계층
- 모든 비즈니스 로직 처리 (비즈니스 로직: 서비스를 만들기 위한 로직)
- Service
#### 퍼시스턴스 계층
- 모든 데이터베이스 관련 로직
- DAO: 데이터베이스에 접근, 데이터베이스 계층과 상호작용하기 위한 객체
- Repository

### 스프링 부트 프로젝트 디렉토리 구성
#### main
실제 코드를 작성하는 공간
> main/resources/static: JS,CSS, 이미지와 같은 정적 파일을 넣는 용도
>application.yml: 스프링 부트 설정하는 파일로 스프링 부트 서버가 실행되면 자동으로 로딩되는 파일. 데이터베이스의 설정 정보, 로깅 설정 정보 등이 들어갈 수 있고 직접 설정을 정의할 때도 사용됨

#### test
프로젝트의 소스 코드를 테스트할 목적의 코드나 리소스 파일
#### build.gradle
의존성이나 플러그인 설정 등과 같이 빌드에 필요한 설정
```
dependencies에 필요한 의존성 추가
구성+의존성 이름 조합
구성: implementation, testImplementation, runtimeOnly,
compileOnly, annotation Processor 등
의존성: ex) org.springframework.boot spring-boot-starterdata-jpa
```
#### settings.gradle
빌드할 프로젝트의 정보를 설정하는 파일

`@Autowired` : 스프링 컨테이너에 있는 빈 주입하는 역할

### 프레젠테이션, 서비스, 퍼시스턴스 계층 만들기
1단계: 프레젠테이션 계층 - Controller 작성
Service 빈 주입
2단계: 비즈니스 계층 - Service 작성
Repository 빈 주입 받은 후 Repository의 메소드를 호출한다.
3단계: 퍼시스턴트 계층 - DAO
DAO-> 테이블에 접근하는 데 사용할 객체
4단계: 퍼시스턴트 계층 - Repository
테이블과 DAO 클래스를 매핑

### 작동 확인하기
1단계: 더미데이터 생성 > resources 디렉토리에 생성
2단계: YAML 작성
>YAML은 들여쓰기를 사용해 계층 구조를 나타냄!!

3단계: 서버 실행 후 콘솔창에서 테이블이 잘 만들어졌는지 확인
4단계: 포스트맨으로 HTTP 요청

### 스프링 부트 요청-응답 과정
1. 포스트맨에서 톰캣에 GET 요청 => 스프링 부트 내로 이동
 스프링 부트의 디스패처 서블릿이 URL을 분석하고 이 요청을 처리할 수 있는 컨트롤러 찾기.
 2. 컨트롤러안에 GET 요청을 처리할 수 있는 메소드와 요청이 매치됨
 => 비즈니스 계층과 퍼시스턴스 계층을 통해 필요한 데이터 가져옴
 3. 뷰 리졸버는 템플릿 엔진을 사용해 HTML 문서를 만들거나, JSON,XML 등의 데이터 생성
 4. return 한 데이터를 포스트맨 볼 수 있음




