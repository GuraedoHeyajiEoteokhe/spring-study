## 04장. 스프링 부트 3와 테스트

테스트 코드: 작성한 코드가 의도대로 잘 동작하고 예상치 못한 문제가 없는지 확인할 목적으로 작성하는 코드  
**given**(테스트 실행 준비) - **when**(테스트 진행) - **then**(테스트 결과 검증) 패턴 사용

**JUnit**: 자바 프로그래밍 언어용 단위 테스트 프레임워크  
**AssertJ**: 검증문이 어설션을 작성하는 데 사용되는 라이브러리  

```
Assertions.assertEquals(sum, a + b);  
-> assertThat(a + b).isEqualTo(sum); // 가독성을 높이기 위해 AssertJ 사용  
```

lombok: getter, setter, 생성자와 같이 클래스를 만들 때 반복하여 입력하는 코드를 줄여주기 위한 라이브러리

레코드: 필드, 생성자, 게터, equals(), hashCode(), toString() 메서드 등을 자동으로 생성  
ObjectMapper: Jackson 라이브러리에서 제공하는 클래스로 객체와 JSON 간의 변환을 처리

**@Test**: 메서드를 호출할 때마다 새 인스턴스를 생성, 독립 테스트 가능  
**@SpringBootTest**: @SpringBootApplication이 있는 클래스에 포함되어 있는 빈을 찾은 다음 테스트용 애플리케이션 컨텍스트라는 것을 만듬  
-> @Test는 스프링 없이 실행되는 JUnit 테스트, @SpringBootTest는 스프링 컨테이너까지 띄우는 통합 테스트  
**@DisplayName**: 테스트 이름 명시  
**@AutoConfigureMockMvc**: MockMvc를 생성하고 자동으로 구성, 컨트롤러를 테스트할 때 사용되는 클래스  
-perform() 메서드는 요청을 전송하는 역할  
-accept() 메서드는 응답을 검증  
-jsonPath("$[0].${필드명}")은 JSON 응답값의 값을 가져오는 역할  
<img width="599" height="305" alt="화면 캡처 2025-12-01 233443" src="https://github.com/user-attachments/assets/972be66f-f5a7-4a6f-96c9-4b298aab3b98" />

**@BeforeAll**: 전체 테스트를 시작하기 전에 처음으로 한 번만 실행, static으로 선언  
**@BeforeEach**: 각 테스트 케이스를 시작하기 전에 매번 실행, static이 아니어야 함  
**@AfterAll**: 전체 테스트를 마치고 종료하기 전에 한 번만 실행, static으로 선언  
**@AfterEach**: 각 테스트 케이스를 종료하기 전에 매번 실행, static이 아니어야 함  

## 05장. 데이터베이스 조작이 편해지는 ORM

**RDBMS**: 테이블 형태로 이루어진 데이터 저장소 (보통 개발 및 테스트 시에는 H2를, 실제 서버로 올릴 때는 MySQL 사용)  
-> 행(테이블의 가로로 배열된 데이터의 집합), 열(행에 저장되는 유형의 데이터, 무결성 보장), 기본키(식별자), 쿼리 등으로 구성  
-> 쿼리에는 SELECT문, WHERE절, INSERT문, DELETE문, UPDATE문 등이 있음  

**ORM**: 자바의 객체와 데이터베이스를 연결해 자바 언어로만 데이터베이스를 다룰 수 있게 하는 도구  
**JPA**: 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스  
**하이버네이트**: JPA 인터페이스를 구현한 구현체이자 자바용 ORM 프레임워크  

엔티티: 데이터베이스의 테이블과 매핑되는 객체, 엔티티는 객체이긴 하지만 데이터베이스에 영향을 미치는 쿼리를 실행하는 객체  
엔티티 매니저: 데이터페이스와 어플리케이션 사이에서 객체를 생성, 수정, 삭제하는 등의 역할을 함

**@PersistenceContext**: 스프링이 EntityManager를 주입해주는 어노테이션  
**@Sql**: 테스트 전에 SQL 스크립트 실행  
**@DataJpaTest**: 테스트를 위한 설정 제공, 자동으로 데이터베이스에 대한 트랜잭션 관리를 설정 (@Transactional 포함)  
**@Transactional**: 트랜잭션 범위 지정  
**@GeneratedValue**: 기본키의 생성 방식 결정  
**@Column**: 데이터베이스의 컬럼과 필드 매핑

**영속성 컨텍스트**: 엔티티를 관리하는 가상의 공간  
-**1차 캐시**: 캐시된 데이터를 조회할 때는 데이터베이스를 거치지 않아도 되므로 매우 빠르게 데이터 조회 가능  
-**쓰기 지연**: 트랜잭션을 커밋하기 전까지는 데이터베이스에 질의문을 보내지 않고 모아뒀다가 커밋하면 한번에 실행  
-**변경 감지**: 트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 감지해 데이터베이스에 자동으로 반영  
-**지연 로딩**: 쿼리로 요청한 데이터를 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터를 조회  
-> 데이터베이스의 접근을 최소화해 성능을 높일 수 있음  


```
@PersistenceContext
EntityManager em; // 프록시 엔티티 매니저, 필요할 때 진짜 엔티티 매니저 호출
```

엔티티의 상태: 분리 상태(detach()), 관리 상태(persist()), 비영속 상태(엔티티를 처음 만들 때), 삭제된 상태(remove())

**스프링 데이터**: 비즈니스 로직에 더 집중할 수 있게 데이터베이스 사용 기능을 클래스 레벨에서 추상화  
**스프링 데이터 JPA**: 스프링 데이터의 공통적인 기능에서 JPA의 유용한 기술이 추가

스프링 데이터 JPA에서 제공하는 메서드: findAll(), findById(), save(), saveAll(), deleteById(), deleteAll() 등  
데이터를 수정할 때는 그냥 메서드만 사용하면 안 되고 @Transactional 어노테이션을 추가해야 함

### ✏️ 2주차 스터디 리뷰
스프링 테스트에서는 given–when–then 구조를 사용해 테스트의 흐름을 나누고, 의도한 로직이 제대로 동작하는지 검증한다.
ORM·JPA 학습에서는 엔티티가 테이블과 매핑되고 관리되는 과정을 이해하는 것이 핵심이었다.
특히 영속성 컨텍스트의 1차 캐시, 변경 감지, 지연 로딩이 JPA 성능과 편의성을 책임지는 중요한 동작 원리임을 알게 되었다.
이번 주 학습을 통해 테스트 구조와 JPA의 내부 메커니즘을 더 분명하게 이해할 수 있었고, 실습에 적용하면 큰 도움이 될 것 같다.

---
### 리뷰어 : 정하경
- 전체적으로 핵심 개념이 잘 정돈되어있어 좋았습니다.<br>
특히 각 어노테이션들이 무슨 역할을 하는지에 대해 정리가 잘 되어있어 참고하기 좋았습니다.
