# Chap04 스프링 부트3와 테스트
### 테스트 코드
작성한 코드가 의도대로 잘 동작하고 예상치 못한 문제가 없는지 확인할 목적으로 작성하는 코드이다. 테스트 코드에도 다양한 패턴이 있으며 그 중 given-when-then패턴에 대해 알아볼 것이다.
### given-when-then 패턴
1. given: 테스트 실행을 준비하는 단계
2. when: 테스트를 진행하는 단계
3. then: 테스트 결과를 검증하는 단계

spring-boot-starter-test 스타터에 테스트를 위한 도구가 모여있으며 그 중 JUnit과 AssertJ를 가장 많이 사용한다.
### JUnit
- 자바 언어를 위한 단위 테스트 프레임워크
- 메서드 단위로 테스트를 작성하고 테스트하는 데 도움을 준다.
- 테스트끼리 영향을 주지 않도록 각각의 테스트마다 실행 객체를 생성하며 테스트가 끝나면 생성한 객체를 삭제한다.
- 테스트 케이스가 하나라도 실패하면 전체 테스트를 실패한 것으로 보여준다. 

#### @DisplayName
-  테스트 이름 명시

#### @Test
- 테스트를 수행하는 메서드
#### @BeforeAll
- 전체 테스트를 시작하기 전 처음으로 한 번만 실행된다.
- 전체 테스트 실행 주기에서 한 번만 호출되어야 하기 때문에 메서드를 static으로 선언해야 한다.
#### @BeforEach
- 각 테스트 케이스를 시작하기 전 매번 실행된다.
- 테스트 메서드에서 사용하는 객체를 초기화하거나 테스트에 필요한 값을 미리 넣을 때 사용할 수 있다.
- 각 인스턴스에 대해 메서드를 호출해야 하므로 static이 아니어야 한다.
#### @AfterAll
- 전체 테스트를 마치고 종료하기 전에 한 번만 실행된다.
- 데이터베이스 연결을 종료할 때나 공통적으로 사용하는 자원을 해제할 때 사용할 수 있다.
- 전체 테스트 실행 주기에서 한 번만 호출되어야 하기 때문에 메서드를 static으로 선언해야 한다.
#### @AfterEach
- 각 테스트 케이스를 종료하기 전 매번 실행된다.
- 테스트 이후에 특정 데이터를 삭제해야 하는 경우 사용
- 각 인스턴스에 대해 메소드를 호출해야 하므로 static이 아니어야 한다.

> @BeforeAll/@AfterAll
>>인스턴스가 없을 때 호출하기 때문에 static으로 선언된다.

> @BerforeEach/@AferEach
>>각 테스트 인스턴스의 필드/상태를 세팅하는 용도라서 인스턴스 메서드여야 한다.

---

1. @BeforeAll: 클래스 레벨 설정
2. @BeforeEach: 메서드 레벨 설정
3. @Teste: 테스트 실행
4. @AfterEach: 메서드 레벨 정리
5. @AfterAll: 클래스 레벨 정리
2-3-4 : 테스트 개수만큼 반복
---
### AssertJ
- AssertJ는 JUnit과 함께 사용해 검증문의 가독성을 높여주는 라이브러리이다.

#### @SpringBootTest
- @SpringBootApplication이 있는 클래스를 찾고 그 클래스에 포함되어 있는 빈을 찾은 다음 테스트용 애플리케이션 컨텍스트를 만든다.
#### @ AutoConfigueMockMvc
MockMvc 생성 및 자동 구성한다.
>- MockMvc는 컨트롤러 테스트를 위해 HTTP 요청을 가짜로 만들어 실행시키는 테스트 도구이다.
- 서버 실행 없이 빠르게 웹 요청/응답의 동작을 검증할 수 있다.

#### perform()
- 요청을 전송하는 역할을 한다.
- 결과로 ResultActions 객체를 받으며, ResultActions 객체는 반환값을 검증하고 확인하는 andExpect() 메서드를 제공한다.
> ResultActions: MockMvc로 보낸 HTTP 요청의 결과에 대해 여러 가지 검증이랑 후처리를 체이닝 형식으로 이어붙이게 해주는 객체

#### accept()
- 요청을 보낼 때 무슨 타입으로 응답을 받을지 결정하는 메서드이다.
#### andExpect()
- 응답을 검증한다.
#### jsonPath("$[0].${필드명}")
- JSON 응답값의 값을 가져오는 역할을 하는 메서드이다.

##### 📌 HTTP 주요 응답 코드 (MockMvc 상태 검증 메서드)
| 코드                            | 매핑 메서드                    | 설명                                             |
| ----------------------------- | ------------------------- | ---------------------------------------------- |
| **200 OK**                    | `isOk()`                  | HTTP 응답 코드가 **200 OK**인지 검증                    |
| **201 Created**               | `isCreated()`             | HTTP 응답 코드가 **201 Created**인지 검증               |
| **400 Bad Request**           | `isBadRequest()`          | HTTP 응답 코드가 **400 Bad Request**인지 검증           |
| **403 Forbidden**             | `isForbidden()`           | HTTP 응답 코드가 **403 Forbidden**인지 검증             |
| **404 Not Found**             | `isNotFound()`            | HTTP 응답 코드가 **404 Not Found**인지 검증             |
| **4xx 응답 코드**                 | `is4xxClientError()`      | HTTP 응답 코드가 **4xx(Client Error)** 범위인지 검증      |
| **500 Internal Server Error** | `isInternalServerError()` | HTTP 응답 코드가 **500 Internal Server Error**인지 검증 |
| **5xx 응답 코드**                 | `is5xxServerError()`      | HTTP 응답 코드가 **5xx(Server Error)** 범위인지 검증      |

#### Object Mapper
- Jackson 라이브러리에서 제공하는 클래스로 객체와 JSON 간의 변환을 처리해준다.

> 예시
```java
Code code = new Code(13)
objectMapper.writeValueAsString(code)
```
>
```
{'value' : 13}
```

#### WebApplicationContext
- Spring MVC 웹 애플리케이션의 모든 Bean과 설정을 담고 관리하는 웹 컨텍스트(환경 컨테이너)
- MockMvc는 이 컨텍스트를 이용해 웹 요청을 테스트한다.
```java
@Autowired
private WebApplicationContext context;

@BeforeEach
void setUp() {
    mockMvc = MockMvcBuilders.webAppContextSetup(context).build();
}
```
---
### AssertJ 메서드

#### ✅ 기본 값/동등성/널 검사 관련

| 메서드 이름            | 의미 / 검증 내용                    |
| ----------------- | ----------------------------- |
| `isEqualTo(A)`    | 값이 **A와 같은지** 검증              |
| `isNotEqualTo(A)` | 값이 **A와 다른지** 검증              |
| `isNull()`        | 값이 **null인지** 검증              |
| `isNotNull()`     | 값이 **null이 아닌지** 검증           |
| `isSameAs(A)`     | **같은 객체 인스턴스인지** 검증 (`==` 기준) |
| `isNotSameAs(A)`  | **다른 객체 인스턴스인지** 검증           |

#### 🧵 문자열 / 컬렉션 / 배열 공통: 포함·비어 있음
| 메서드 이름                  | 의미 / 검증 내용                          |
| ----------------------- | ----------------------------------- |
| `contains(A)`           | **A 값을 포함하는지** 검증 (문자열, 컬렉션, 배열 등)  |
| `doesNotContain(A)`     | **A 값을 포함하지 않는지** 검증                |
| `startsWith(A)`         | 문자열의 **접두사(prefix)가 A인지** 검증        |
| `endsWith(A)`           | 문자열의 **접미사(suffix)가 A인지** 검증        |
| `isEmpty()`             | **비어 있는지** 검증 (`""`, 빈 컬렉션, 빈 배열 등) |
| `isNotEmpty()`          | **비어 있지 않은지** 검증                    |
| `hasSize(n)`            | 컬렉션/배열/문자열의 **크기(길이)가 n인지** 검증      |
| `hasSizeGreaterThan(n)` | 크기가 **n보다 큰지** 검증                   |
| `hasSizeLessThan(n)`    | 크기가 **n보다 작은지** 검증                  |
#### 🔢 숫자 관련 (양수/음수/비교/0)
| 메서드 이름                      | 의미 / 검증 내용                    |
| --------------------------- | ----------------------------- |
| `isPositive()`              | **양수인지** 검증 (`> 0`)           |
| `isNegative()`              | **음수인지** 검증 (`< 0`)           |
| `isZero()`                  | **0인지** 검증                    |
| `isGreaterThan(A)`          | **A보다 큰 값인지** 검증              |
| `isLessThan(A)`             | **A보다 작은 값인지** 검증             |
| `isGreaterThanOrEqualTo(A)` | **A 이상인지** 검증                 |
| `isLessThanOrEqualTo(A)`    | **A 이하인지** 검증                 |
| `isBetween(A, B)`           | **A 이상 B 이하 범위인지** 검증 (포함 범위) |
#### 🧩 타입 / 인스턴스 관련
| 메서드 이름                       | 의미 / 검증 내용                  |
| ---------------------------- | --------------------------- |
| `isInstanceOf(Class)`        | 주어진 **클래스 타입의 인스턴스인지** 검증   |
| `isNotInstanceOf(Class)`     | **그 타입이 아닌지** 검증            |
| `isExactlyInstanceOf(Class)` | 상속 포함 말고, **정확히 그 타입인지** 검증 |
#### ✅ Boolean / 조건 관련
| 메서드 이름            | 의미 / 검증 내용                                     |
| ----------------- | ---------------------------------------------- |
| `isTrue()`        | 값이 `true` 인지 검증                                |
| `isFalse()`       | 값이 `false` 인지 검증                               |
| `isEqualTo(true)` | 사실상 `isTrue()`와 동일 (하지만 가독성 면에서 `isTrue()` 선호) |
#### ⚠️예외 관련 (자주 쓰여서 서비스 코드 테스트에 필수급)
| 메서드 이름                        | 의미 / 검증 내용                   |
| ----------------------------- | ---------------------------- |
| `assertThatThrownBy(…)`       | **해당 람다 코드에서 던지는 예외를 검증**    |
| `isInstanceOf(A.class)`       | 던져진 예외가 **A 타입인지** 검증        |
| `hasMessage(String)`          | 예외 메시지가 **정확히 일치하는지** 검증     |
| `hasMessageContaining("문자열")` | 예외 메시지가 **해당 문자열을 포함하는지** 검증 |
예시)
```java
assertThatThrownBy(() -> {
    // 예외가 발생해야 하는 코드
}).isInstanceOf(IllegalArgumentException.class)
  .hasMessageContaining("잘못된 값");
```
---
### MockMvc / ResultActions 쓸 때 자주 나오는 메서드들
#### 1️⃣ 요청 만들 때 (MockMvc, MockMvcRequestBuilders)

```java
mockMvc.perform( ... )
```
안에 주로 들어가는 것들 👇

| 메서드 / 형태                                   | 역할                                  |
| ------------------------------------------ | ----------------------------------- |
| `get("URL")`                               | GET 요청 보내기                          |
| `post("URL")`                              | POST 요청 보내기                         |
| `put("URL")`                               | PUT 요청 보내기                          |
| `delete("URL")`                            | DELETE 요청 보내기                       |
| `patch("URL")`                             | PATCH 요청 보내기                        |
| `.param("name", "value")`                  | 쿼리 파라미터 / 폼 파라미터 추가 (`?name=value`) |
| `.header("헤더이름", "값")`                     | HTTP 헤더 추가                          |
| `.contentType(MediaType.APPLICATION_JSON)` | 요청 본문 타입 지정 (`Content-Type`)        |
| `.accept(MediaType.APPLICATION_JSON)`      | 응답으로 받고 싶은 타입 지정 (`Accept`)         |
| `.content(String json)`                    | 요청 body(주로 JSON 문자열) 넣기             |
| `.cookie(Cookie...)`                       | 쿠키 추가                               |
#### 2️⃣ 결과 검증 / 후처리 (ResultActions 관련)
```java
mockMvc.perform(...)
       .andExpect(...)
       .andDo(...)
       .andReturn();
```
여기에 자주 쓰는 것들 👇
##### 🔹 ResultActions 메서드

| 메서드             | 역할                         |
| --------------- | -------------------------- |
| `.andExpect(…)` | 응답에 대한 **검증** (상태코드, 내용 등) |
| `.andDo(…)`     | 응답을 **출력하거나, 추가 작업** 수행    |
| `.andReturn()`  | 최종 결과를 `MvcResult`로 **반환** |

##### 🔹 상태 코드 검증 (status())
```java
.andExpect(status().isOk())
```
| 메서드                           | 역할                 |
| ----------------------------- | ------------------ |
| `status().isOk()`             | 200 OK 인지 검증       |
| `status().isCreated()`        | 201 Created 인지     |
| `status().isBadRequest()`     | 400 Bad Request 인지 |
| `status().isUnauthorized()`   | 401 인지             |
| `status().isForbidden()`      | 403 인지             |
| `status().isNotFound()`       | 404 인지             |
| `status().is5xxServerError()` | 500번대 에러인지         |
##### 🔹 응답 본문 검증 (content(), jsonPath())
| 메서드                              | 역할                           |
| -------------------------------- | ---------------------------- |
| `content().string("텍스트")`        | 응답 body가 **해당 문자열과 같은지**     |
| `content().json("JSON문자열")`      | 응답 body가 **JSON 구조로 같은지**    |
| `content().contentType("타입")`    | 응답의 `Content-Type` 검증        |
| `jsonPath("$.name").value("세현")` | JSON 응답에서 `name` 값이 `"세현"`인지 |
| `jsonPath("$.age").isNumber()`   | `age` 필드가 숫자인지               |
| `jsonPath("$.list").isArray()`   | `list`가 배열인지                 |
##### 🔹 헤더 / 뷰 / 리다이렉트 검증
| 메서드                                                   | 역할                             |
| ----------------------------------------------------- | ------------------------------ |
| `header().exists("Authorization")`                    | 해당 헤더가 존재하는지                   |
| `header().string("Content-Type", "application/json")` | 헤더 값 비교                        |
| `view().name("뷰이름")`                                  | 리턴된 뷰 이름 검증 (Thymeleaf, JSP 등) |
| `redirectedUrl("/login")`                             | 리다이렉트된 URL 검증                  |
| `redirectedUrlPattern("/users/*")`                    | 리다이렉트 URL 패턴 검증                |
##### 🔹 andDo()에서 자주 쓰는 것
| 메서드              | 역할                                |
| ---------------- | --------------------------------- |
| `andDo(print())` | 요청/응답 전체를 콘솔에 예쁘게 출력 (디버깅할 때 필수템) |

#### 3️⃣ 결과 꺼내쓰기 (MvcResult)
andReturn()으로 받는 MvcResult에서 자주 쓰는 애들 👇
```JAVA
MvcResult result = mockMvc.perform(...).andReturn();
```
| 메서드                                         | 역할                |
| ------------------------------------------- | ----------------- |
| `result.getResponse().getStatus()`          | 응답 상태 코드 가져오기     |
| `result.getResponse().getContentAsString()` | 응답 body 문자열로 가져오기 |
| `result.getResponse().getHeader("헤더이름")`    | 특정 응답 헤더 값 가져오기   |

# Chap05. 데이터베이스 조작이 편해지는 ORM
#### 데이터베이스 관리자, DBMS
데이터베이스를 관리하기 위한 소프트웨어 (database management system)
##### 관계형 DBMS (RDBMS)
테이블 형태로 이루어진 데이터 저장소
- H2
	자바로 작성되어 있는 RDBMS
    스프링 부트가 지원하는 인메모리 관계형 데이터베이스
    데이터를 다른 공간에 따로 보관하는 것이 아니라 애플리케이션 자체 내부에 데이터를 저장한다. => 애플리케이션 재실행 시 데이터 초기화된다.
    간편하게 사용하기 좋기 때문에 테스트 용도로 많이 사용된다.
- mysql
	실제 서비스에서는 MySql같은 제품으 많이 사용한다.
   
>- 테이블
	데이터베이스에서 데이터를 구성하기 위한 가장 기본적인 단위로 행과 열로 이루어져 있다.
 - 행
 	테이블의 가로로 배열된 데이터의 집합으로 레코드라고 부르기도 한다.
 - 열
 	행에 저장되는 유형의 데이터로 각 요소에 대한 속성을 나타내며 무결성을 보장한다.
 - 기본키
 	행을 구분할 수 있는 식별자로 테이블에서 유일해야 하며 중복 값을 가질 수 없다. 기본키의 값은 수정되어서는 안되며 유효한 값이어야 한다.(NOT NULL)
 - 쿼리
 	데이터베이스에서 데이터를 조회하거나 색제, 생성, 수정 같은 처리를 하기 위해 사용하는 명령문이다.
    
- 데이터 조회 select문
```
SELECT <무엇을?>
FROM <어디에서?>
WHERE <무슨?>
```
- 데이터 삽입 insert문
```
INSERT INTO <어디에?>
VALUES <어떤 값을?>
```
- 데이터 삭제 delete문
```
DELETE FROM 〈어디에서> WHERE <어떤 조건으로?>;
```
- 데이터 수정 update문
```
UPDATE <어디에?>
SET <무슨 컬럼을? = 어떤 값으로?>
WHERE <어떤 조건으로?>
```

### ORM
- 자바의 객체와 데이터베이스를 연결하는 프로그래밍 기법이다.
- 데이터베이스의 값을 마치 객체처럼 사용할 수 있다.
- 객체와 데이터베이스를 연결해 자바 언어로만 데이터베이스를 다룰 수 있게 하는 도구이다.
- 장점: sql 직접 작성 X, 객체지향적으로 코드 작성이 가능하므로 비즈니스 로직에만 집중 가능, 데이터베이스 시스템에 대한 종속성이 줄어듦, ERD에 의한 의존도를 낮추고 유지보수하기 유리
- 단점: 프로젝트의 복잡성이 커질수록 사용 난이도가 상승, 복잡하고 무거운 쿼리는 ORM으로 해결이 불가능할 수 있음

### JPA, 하이버네트
#### JPA
- 자바에서 사용하는 ORM
- 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스
- 인터페이스이므로 실제 사용을 위해서는 ORM 프레임워크를 추가로 선택해야한다. => 하이버네트(hibernate)
#### 하이버네트
- JPA 인터페이스를 구현한 구현체이자 자바용 ORM 프레임워크
- 내부적으로는 JDBS API 사용
- 자바 객체를 통해 데이터베이스 종류와 상관없이 데이터베이스를 자유자재로 사용할 수 있게 한다.

#### 엔티티
- 데이터베이스의 테이블과 매핑되는 객체
- 본질적으로는 자바 객체이므로 일반 객체와 다르지 않지만, 데이터베이스의 테이블과 직접 연결된다는 특별한 특징이 있어 구분지어 부른다.
- 데이터베이스에 영향을 미치는 쿼리를 실행하는 객체이다.

#### 엔티티 매니저
- 엔티티를 관리해 데이터베이스와 애플리케이션 사이에서 객체를 생성, 수정, 삭제하는 등의 역할
- **엔티티 매니저 팩토리**: 엔티티 매니저를 만드는 곳
- 요청에 대해 처리를 할 엔티티 매니저를 엔티티 매니저 팩토리가 생성한다. 요청 여러 개가 동시에 발생할 수 있다.

> - 스프링 부트에서는 엔티티 매니저 팩토리를 하나만 생성해서 관리하고 @PersistenceContext 또는 @Autowired 애너테이션을 사용해서 엔티티 매니저를 사용한다.
- 스프링 부트는 실제 엔티티 매니저와 연결하는 프록시(가짜)엔티티가 존재해서 필요할 때 데이터베이스 트랜잭션과 관련된 실제 앤티티 매니저를 호출한다.
=> 엔티티 매니저는 spring data jpa에서 관리하기 때문에 직접 생성하거나 관리할 필요 없다.

#### 영속성 컨텍스트
- 엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다는 특징이 있다.
- 엔티티를 관리하는 가상의 공간
1. 1차 캐시
- 캐시의 키는 @Id가 붙은 식별자이며 값은 엔티티이다.
	1) 엔티티 조회
    2) 1차 캐시에서 데이터 조회
       - 값이 있으면 반환
       - 값이 없으면 데이터베이스에서 조회해 1차 캐시에 저장한 후 반환
 => 캐시된 데이터를 조회할 때에는 데이터베이스를 거치지 않아도 되므로 매우 빠르게 데이터를 조회할 수 있다.
 2. 쓰기 지연
 - 트랜잭션을 커밋하기 전까지 데이터베이스에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랜잭션을 커밋하면 모았던 쿼리를 한번에 실행하는 것이다.
 - 적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스 시스템의 부담을 줄일 수 있다.
 3. 변경 감지
 - 트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값을 현재 엔티티의 값을 비교해서 변경된 값이 있다면 변경 사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영한다.
 - 적당한 묶음으로 쿼리를 요청할 수 있고 데이터베이스 시스템의 부담을 줄일 수 있다.
 4. 지연 로딩
 - 쿼리로 요청한 데이터를 애플리케이션에 바로 로딩하는 것이 아니라 필요할 때 쿼리를 날려 데이터를 조회하는 것을 의미한다.
 
> 데이터베이스의 접근을 최소화해 성능을 높일 수 있다.

#### 엔티티의 상태
1. 분리 상태 (detached)
2. 관리 상태 (managed)
3. 비영속 상태 (transient)
4. 삭제된 상태 (removed)

#### 스프링 데이터 JPA
- PagingAndSortingRepository를 상속받아 JpaRepository 인터페이스를 만들었고 JPA를 더 편리하게 사용하는 메서드를 제공한다.
- 리포지터리 역할을 하는 인터페이스를 만들어 데이터베이스의 테이블 조회, 수정, 생성, 삭제 같은 작업을 간단히 할 수 있다.
```java
public interface MemberRepository extends JpaRepository<Member, Long> {
}
```
##### 조회 메서드
- 기본키로 조회하는 경우
- findAll(): 전체 조회
- findById(): 아이디로 조회
- @Sql: 테스트를 실행하기 전에 SQL 스크립트를 실행시킬 수 있다.
```java
public interface MemberRepository extends JpaRepository<Member, Long> {
}
```
##### 쿼리 메서드
- 기본키가 아닌 컬럼으로 조회하는 경우
- 값이 없는 행이 존재할 수 있으므로 JPA에서 기본으로 찾아주는 메서드를 지원하지 않지만 JPA는 쿼리를 작성해 조회할 수 있는 기능을 제공한다.
- 특정 컬럼으로 조회 -> 쿼리 메서드 명명 규칙에 맞게 정의 후 사용
- ex) findByName() 메서드 추가
```
@Repository
public interface MemberRepository extends JpaRepository<Member, Long>{
Optional<Member> findByName(String name);
}
```
- 이 메서드는 상속받아 구현할 필요 X, 메서드로 정의한 후 가져다 쓰기만 하면 된다.
##### 입력 메서드
- save(): 레코드 추가
- saveAll(): 한꺼번에 여러 레코드 추가
##### 추가,삭제 메서드
- deleteById(): 아이디로 레코드 삭제
- deleteAll(): 모든 레코드 삭제
=> 모든 데이터를 삭제하므로 실제 서비스 코드에서는 거의 사용하지 않음
=> 테스트 간의 격리를 보장하기 위해 사용함
=> 보통 @AfterEach에 cleanUp() 메서드와 같은 형태로 사용
##### 수정 메서드
- @Transactional
```java
public class Member{
	... 생략 ...
public void changeName(String name) {
	this.name = name;
	}
}
```
- 이 메서드가 @Transactional 애너테이션이 포함된 메서드에서 호출되면 JPA는 변경 감지 기능을 통해 엔티티의 필드값이 변경될 때 그 변경 사항을 데이터베이스에 자동으로 반영한다.
- @DataJpaTest은 테스트를 위한 설정을 제공하고 자동으로 데이터베이스에 대한 트랜잭션 관리를 설정하기 때문에 이 애너테이션이 존재할 경우 @Transactional을 붙이지 않아도 업데이트 된다.
- 서비스 코드에서는 @Transactional이 반드시 필요하다.

2주차 정리

테스트 코드는 작성한 코드가 의도대로 잘 동작하는지 확인할 수 있는 코드이다. 많은 유형이 있지만 그 중 given-when-then 방식으로 테스트 코드를
어떻게 작성하는지에 대해 공부했다. 테스트 코드에서 많이 사용되는 애너테이션, 메서드 등을 정리했고 이것들을 직접 사용해보면서 익혀야겠다.
데이터베이스를 관리해주는 ORM중 JPA에 대해 학습했다. 원래는 sql문을 작성해 데이터베이스에 접근했다면, ORM을 사용해 자바 언어로 데이터베이스를 다룰 수 있다.
영속성 컨텍스트를 통해 데이터베이스의 접근을 최소화하며 jpa 메서드를 통해 간편하게 데이터를 조회,입력,추가,삭제,수정할 수 있다.
jpa메서드도 직접 사용하면서 익혀야겠다.



